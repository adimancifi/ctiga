<?php defined('BASEPATH') OR exit('No direct script access allowed');
/** 
 *
 * - File    : Unzip.php
 *
 * --------------------------------------------------------------------------------
 * PhpConcept Library - Zip Module 2.6
 * --------------------------------------------------------------------------------
 * License GNU/LGPL - Vincent Blavet - March 2006
 * http://www.phpconcept.net
 * --------------------------------------------------------------------------------
 *
 * Presentation :
 *   PclZip is a PHP library that manage ZIP archives.
 *   So far tests show that archives generated by PclZip are readable by
 *   WinZip application and other tools.
 *
 * Description :
 *   See readme.txt and http://www.phpconcept.net
 *
 * Warning :
 *   This library and the associated files are non commercial, non professional
 *   work.
 *   It should not have unexpected results. However if any damage is caused by
 *   this software the author can not be responsible.
 *   The use of this software is at the risk of the user.
 *
 * --------------------------------------------------------------------------------
 * $Id: pclzip.lib.php,v 1.47 2007/07/20 13:56:07 vblavet Exp $
 * --------------------------------------------------------------------------------
 */

class Unzip {
	
	var $zipname = '';
	var $zip_fd = 0;
	var $error_code = 1;
	var $error_string = '';
	var $magic_quotes_status;
	
	public function __construct($p_zipname)
	{
		if (!defined('ZIP_READ_BLOCK_SIZE')) {
			define('ZIP_READ_BLOCK_SIZE', 2048);
		}
		if (!defined('ZIP_SEPARATOR')) {
			define('ZIP_SEPARATOR', ',');
		}
		if (!defined('ZIP_ERROR_EXTERNAL')) {
			define('ZIP_ERROR_EXTERNAL', 0);
		}
		define('ZIP_TEMPORARY_DIR', realpath(dirname(__FILE__) . '/cache/') . '/');
		if (!defined('ZIP_TEMPORARY_DIR')) {
			define('ZIP_TEMPORARY_DIR', '');
		}
		define('ZIP_ERR_USER_ABORTED', 2);
		define('ZIP_ERR_NO_ERROR', 0);
		define('ZIP_ERR_WRITE_OPEN_FAIL', -1);
		define('ZIP_ERR_READ_OPEN_FAIL', -2);
		define('ZIP_ERR_INVALID_PARAMETER', -3);
		define('ZIP_ERR_MISSING_FILE', -4);
		define('ZIP_ERR_FILENAME_TOO_LONG', -5);
		define('ZIP_ERR_INVALID_ZIP', -6);
		define('ZIP_ERR_BAD_EXTRACTED_FILE', -7);
		define('ZIP_ERR_DIR_CREATE_FAIL', -8);
		define('ZIP_ERR_BAD_EXTENSION', -9);
		define('ZIP_ERR_BAD_FORMAT', -10);
		define('ZIP_ERR_DELETE_FILE_FAIL', -11);
		define('ZIP_ERR_RENAME_FILE_FAIL', -12);
		define('ZIP_ERR_BAD_CHECKSUM', -13);
		define('ZIP_ERR_INVALID_ARCHIVE_ZIP', -14);
		define('ZIP_ERR_MISSING_OPTION_VALUE', -15);
		define('ZIP_ERR_INVALID_OPTION_VALUE', -16);
		define('ZIP_ERR_ALREADY_A_DIRECTORY', -17);
		define('ZIP_ERR_UNSUPPORTED_COMPRESSION', -18);
		define('ZIP_ERR_UNSUPPORTED_ENCRYPTION', -19);
		define('ZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20);
		define('ZIP_ERR_DIRECTORY_RESTRICTION', -21);
		define('ZIP_OPT_PATH', 77001);
		define('ZIP_OPT_ADD_PATH', 77002);
		define('ZIP_OPT_REMOVE_PATH', 77003);
		define('ZIP_OPT_REMOVE_ALL_PATH', 77004);
		define('ZIP_OPT_SET_CHMOD', 77005);
		define('ZIP_OPT_EXTRACT_AS_STRING', 77006);
		define('ZIP_OPT_NO_COMPRESSION', 77007);
		define('ZIP_OPT_BY_NAME', 77008);
		define('ZIP_OPT_BY_INDEX', 77009);
		define('ZIP_OPT_BY_EREG', 77010);
		define('ZIP_OPT_BY_PREG', 77011);
		define('ZIP_OPT_COMMENT', 77012);
		define('ZIP_OPT_ADD_COMMENT', 77013);
		define('ZIP_OPT_PREPEND_COMMENT', 77014);
		define('ZIP_OPT_EXTRACT_IN_OUTPUT', 77015);
		define('ZIP_OPT_REPLACE_NEWER', 77016);
		define('ZIP_OPT_STOP_ON_ERROR', 77017);
		define('ZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019);
		define('ZIP_ATT_FILE_NAME', 79001);
		define('ZIP_ATT_FILE_NEW_SHORT_NAME', 79002);
		define('ZIP_ATT_FILE_NEW_FULL_NAME', 79003);
		define('ZIP_ATT_FILE_MTIME', 79004);
		define('ZIP_ATT_FILE_CONTENT', 79005);
		define('ZIP_ATT_FILE_COMMENT', 79006);
		define('ZIP_CB_PRE_EXTRACT', 78001);
		define('ZIP_CB_POST_EXTRACT', 78002);
		define('ZIP_CB_PRE_ADD', 78003);
		define('ZIP_CB_POST_ADD', 78004);
		if (!function_exists('gzopen')) {
			die('Abort ' . basename(__FILE__) . ' : Missing zlib extensions');
		}
		$this->zipname             = $p_zipname[0];
		$this->zip_fd              = 0;
		$this->magic_quotes_status = -1;
	}
	
	// ----------------------------------------------------------------------

	public function create($p_filelist)
	{
		$v_result = 1;
		$this->privErrorReset();
		$v_options                            = array();
		$v_options[ZIP_OPT_NO_COMPRESSION] = FALSE;
		$v_size                               = func_num_args();
		if ($v_size > 1) {
			$v_arg_list = func_get_args();
			array_shift($v_arg_list);
			$v_size--;
			if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
				$v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(
					ZIP_OPT_REMOVE_PATH => 'optional',
					ZIP_OPT_REMOVE_ALL_PATH => 'optional',
					ZIP_OPT_ADD_PATH => 'optional',
					ZIP_CB_PRE_ADD => 'optional',
					ZIP_CB_POST_ADD => 'optional',
					ZIP_OPT_NO_COMPRESSION => 'optional',
					ZIP_OPT_COMMENT => 'optional'
				));
				if ($v_result != 1) {
					return 0;
				}
			} else {
				$v_options[ZIP_OPT_ADD_PATH] = $v_arg_list[0];
				if ($v_size == 2) {
					$v_options[ZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
				} else if ($v_size > 2) {
					$this->privErrorLog(ZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");
					return 0;
				}
			}
		}
		$v_string_list    = array();
		$v_att_list       = array();
		$v_filedescr_list = array();
		$p_result_list    = array();
		if (is_array($p_filelist)) {
			if (isset($p_filelist[0]) && is_array($p_filelist[0])) {
				$v_att_list = $p_filelist;
			} else {
				$v_string_list = $p_filelist;
			}
		} else if (is_string($p_filelist)) {
			$v_string_list = explode(ZIP_SEPARATOR, $p_filelist);
		} else {
			$this->privErrorLog(ZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");
			return 0;
		}
		if (sizeof($v_string_list) != 0) {
			foreach ($v_string_list as $v_string) {
				if ($v_string != '') {
					$v_att_list[][ZIP_ATT_FILE_NAME] = $v_string;
				} else {
				}
			}
		}
		$v_supported_attributes = array(
			ZIP_ATT_FILE_NAME => 'mandatory',
			ZIP_ATT_FILE_NEW_SHORT_NAME => 'optional',
			ZIP_ATT_FILE_NEW_FULL_NAME => 'optional',
			ZIP_ATT_FILE_MTIME => 'optional',
			ZIP_ATT_FILE_CONTENT => 'optional',
			ZIP_ATT_FILE_COMMENT => 'optional'
		);
		foreach ($v_att_list as $v_entry) {
			$v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
			if ($v_result != 1) {
				return 0;
			}
		}
		$v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);
		if ($v_result != 1) {
			return 0;
		}
		$v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);
		if ($v_result != 1) {
			return 0;
		}
		return $p_result_list;
	}

	// ----------------------------------------------------------------------

	public function extract($path)
	{
		$v_result = 1;
		$this->privErrorReset();
		if (!$this->privCheckFormat()) {
			return (0);
		}
		$v_options                               = array();
		$v_path                                  = '';
		$v_remove_path                           = "";
		$v_remove_all_path                       = false;
		$v_size                                  = 2;
		$v_options[ZIP_OPT_EXTRACT_AS_STRING] = FALSE;
		
		// $v_arg_list = func_get_args();
		$v_arg_list = array(77001,$path);

		$v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options, array(
			ZIP_OPT_PATH => 'optional',
			ZIP_OPT_REMOVE_PATH => 'optional',
			ZIP_OPT_REMOVE_ALL_PATH => 'optional',
			ZIP_OPT_ADD_PATH => 'optional',
			ZIP_CB_PRE_EXTRACT => 'optional',
			ZIP_CB_POST_EXTRACT => 'optional',
			ZIP_OPT_SET_CHMOD => 'optional',
			ZIP_OPT_BY_NAME => 'optional',
			ZIP_OPT_BY_EREG => 'optional',
			ZIP_OPT_BY_PREG => 'optional',
			ZIP_OPT_BY_INDEX => 'optional',
			ZIP_OPT_EXTRACT_AS_STRING => 'optional',
			ZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',
			ZIP_OPT_REPLACE_NEWER => 'optional',
			ZIP_OPT_STOP_ON_ERROR => 'optional',
			ZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional'
		));
		if ($v_result != 1) {
			return 0;
		}
		if (isset($v_options[ZIP_OPT_PATH])) {
			$v_path = $v_options[ZIP_OPT_PATH];
		}
		if (isset($v_options[ZIP_OPT_REMOVE_PATH])) {
			$v_remove_path = $v_options[ZIP_OPT_REMOVE_PATH];
		}
		if (isset($v_options[ZIP_OPT_REMOVE_ALL_PATH])) {
			$v_remove_all_path = $v_options[ZIP_OPT_REMOVE_ALL_PATH];
		}
		if (isset($v_options[ZIP_OPT_ADD_PATH])) {
			if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {
				$v_path .= '/';
			}
			$v_path .= $v_options[ZIP_OPT_ADD_PATH];
		}
		
		$p_list   = array();

		$v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options);

		if ($v_result < 1) 
		{
			unset($p_list);
			return (0);
		}
		return $p_list;
	}
	
	// ----------------------------------------------------------------------

	public function errorCode()
	{
		if (ZIP_ERROR_EXTERNAL == 1) {
			return (PclErrorCode());
		} else {
			return ($this->error_code);
		}
	}
	
	// ----------------------------------------------------------------------

	public function privCheckFormat($p_level = 0)
	{
		$v_result = true;
		clearstatcache();
		$this->privErrorReset();
		if (!is_file($this->zipname)) {
			$this->privErrorLog(ZIP_ERR_MISSING_FILE, "Missing archive file '" . $this->zipname . "'");
			return (false);
		}
		if (!is_readable($this->zipname)) {
			$this->privErrorLog(ZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '" . $this->zipname . "'");
			return (false);
		}
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options = false)
	{
		$v_result = 1;
		$i        = 0;
		while ($i < $p_size) {
			if (!isset($v_requested_options[$p_options_list[$i]])) {
				$this->privErrorLog(ZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '" . $p_options_list[$i] . "' for this method");
				return $this->errorCode();
			}
			switch ($p_options_list[$i]) {
				case ZIP_OPT_PATH:
				case ZIP_OPT_REMOVE_PATH:
				case ZIP_OPT_ADD_PATH:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$v_result_list[$p_options_list[$i]] = $this->PclZipUtilTranslateWinPath($p_options_list[$i + 1], FALSE);
					$i++;
					break;
				case ZIP_OPT_EXTRACT_DIR_RESTRICTION:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					if (is_string($p_options_list[$i + 1]) && ($p_options_list[$i + 1] != '')) {
						$v_result_list[$p_options_list[$i]] = $this->PclZipUtilTranslateWinPath($p_options_list[$i + 1], FALSE);
						$i++;
					} else {
					}
					break;
				case ZIP_OPT_BY_NAME:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					if (is_string($p_options_list[$i + 1])) {
						$v_result_list[$p_options_list[$i]][0] = $p_options_list[$i + 1];
					} else if (is_array($p_options_list[$i + 1])) {
						$v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
					} else {
						$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$i++;
					break;
				case ZIP_OPT_BY_EREG:
				case ZIP_OPT_BY_PREG:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					if (is_string($p_options_list[$i + 1])) {
						$v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
					} else {
						$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$i++;
					break;
				case ZIP_OPT_COMMENT:
				case ZIP_OPT_ADD_COMMENT:
				case ZIP_OPT_PREPEND_COMMENT:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					if (is_string($p_options_list[$i + 1])) {
						$v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
					} else {
						$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$i++;
					break;
				case ZIP_OPT_BY_INDEX:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$v_work_list = array();
					if (is_string($p_options_list[$i + 1])) {
						$p_options_list[$i + 1] = strtr($p_options_list[$i + 1], ' ', '');
						$v_work_list            = explode(",", $p_options_list[$i + 1]);
					} else if (is_integer($p_options_list[$i + 1])) {
						$v_work_list[0] = $p_options_list[$i + 1] . '-' . $p_options_list[$i + 1];
					} else if (is_array($p_options_list[$i + 1])) {
						$v_work_list = $p_options_list[$i + 1];
					} else {
						$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$v_sort_flag  = false;
					$v_sort_value = 0;
					for ($j = 0; $j < sizeof($v_work_list); $j++) {
						$v_item_list      = explode("-", $v_work_list[$j]);
						$v_size_item_list = sizeof($v_item_list);
						if ($v_size_item_list == 1) {
							$v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];
							$v_result_list[$p_options_list[$i]][$j]['end']   = $v_item_list[0];
						} elseif ($v_size_item_list == 2) {
							$v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];
							$v_result_list[$p_options_list[$i]][$j]['end']   = $v_item_list[1];
						} else {
							$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
							return $this->errorCode();
						}
						if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {
							$v_sort_flag = true;
							$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
							return $this->errorCode();
						}
						$v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];
					}
					if ($v_sort_flag) {
					}
					$i++;
					break;
				case ZIP_OPT_REMOVE_ALL_PATH:
				case ZIP_OPT_EXTRACT_AS_STRING:
				case ZIP_OPT_NO_COMPRESSION:
				case ZIP_OPT_EXTRACT_IN_OUTPUT:
				case ZIP_OPT_REPLACE_NEWER:
				case ZIP_OPT_STOP_ON_ERROR:
					$v_result_list[$p_options_list[$i]] = true;
					break;
				case ZIP_OPT_SET_CHMOD:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
					$i++;
					break;
				case ZIP_CB_PRE_EXTRACT:
				case ZIP_CB_POST_EXTRACT:
				case ZIP_CB_PRE_ADD:
				case ZIP_CB_POST_ADD:
					if (($i + 1) >= $p_size) {
						$this->privErrorLog(ZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$v_function_name = $p_options_list[$i + 1];
					if (!function_exists($v_function_name)) {
						$this->privErrorLog(ZIP_ERR_INVALID_OPTION_VALUE, "Function '" . $v_function_name . "()' is not an existing function for option '" . $this->PclZipUtilOptionText($p_options_list[$i]) . "'");
						return $this->errorCode();
					}
					$v_result_list[$p_options_list[$i]] = $v_function_name;
					$i++;
					break;
				default:
					$this->privErrorLog(ZIP_ERR_INVALID_PARAMETER, "Unknown parameter '" . $p_options_list[$i] . "'");
					return $this->errorCode();
			}
			$i++;
		}
		if ($v_requested_options !== false) {
			for ($key = reset($v_requested_options); $key = key($v_requested_options); $key = next($v_requested_options)) {
				if ($v_requested_options[$key] == 'mandatory') {
					if (!isset($v_result_list[$key])) {
						$this->privErrorLog(ZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter " . $this->PclZipUtilOptionText($key) . "(" . $key . ")");
						return $this->errorCode();
					}
				}
			}
		}
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privOpenFd($p_mode)
	{
		$v_result = 1;
		if ($this->zip_fd != 0) {
			$this->privErrorLog(ZIP_ERR_READ_OPEN_FAIL, 'Zip file \'' . $this->zipname . '\' already open');
			return $this->errorCode();
		}
		if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0) {
			$this->privErrorLog(ZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \'' . $this->zipname . '\' in ' . $p_mode . ' mode');
			return $this->errorCode();
		}
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privCloseFd()
	{
		$v_result = 1;
		if ($this->zip_fd != 0)
			@fclose($this->zip_fd);
		$this->zip_fd = 0;
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privConvertHeader2FileInfo($p_header, &$p_info)
	{
		$v_result                  = 1;
		$p_info['filename']        = $p_header['filename'];
		$p_info['stored_filename'] = $p_header['stored_filename'];
		$p_info['size']            = $p_header['size'];
		$p_info['compressed_size'] = $p_header['compressed_size'];
		$p_info['mtime']           = $p_header['mtime'];
		$p_info['comment']         = $p_header['comment'];
		$p_info['folder']          = (($p_header['external'] & 0x00000010) == 0x00000010);
		$p_info['index']           = $p_header['index'];
		$p_info['status']          = $p_header['status'];
		$p_info['crc']             = $p_header['crc'];
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)
	{
		$v_result = 1;
		$this->privDisableMagicQuotes();
		if (($p_path == "") || ((substr($p_path, 0, 1) != "/") && (substr($p_path, 0, 3) != "../") && (substr($p_path, 1, 2) != ":/")))
			$p_path = "./" . $p_path;
		if (($p_path != "./") && ($p_path != "/")) {
			while (substr($p_path, -1) == "/") {
				$p_path = substr($p_path, 0, strlen($p_path) - 1);
			}
		}
		if (($p_remove_path != "") && (substr($p_remove_path, -1) != '/')) {
			$p_remove_path .= '/';
		}
		$p_remove_path_size = strlen($p_remove_path);
		if (($v_result = $this->privOpenFd('rb')) != 1) {
			$this->privSwapBackMagicQuotes();
			return $v_result;
		}
		$v_central_dir = array();
		if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {
			$this->privCloseFd();
			$this->privSwapBackMagicQuotes();
			return $v_result;
		}
		$v_pos_entry = $v_central_dir['offset'];
		$j_start     = 0;
		for ($i = 0, $v_nb_extracted = 0; $i < $v_central_dir['entries']; $i++) {
			@rewind($this->zip_fd);
			if (@fseek($this->zip_fd, $v_pos_entry)) {
				$this->privCloseFd();
				$this->privSwapBackMagicQuotes();
				$this->privErrorLog(ZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');
				return $this->errorCode();
			}
			$v_header = array();
			if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1) {
				$this->privCloseFd();
				$this->privSwapBackMagicQuotes();
				return $v_result;
			}
			$v_header['index'] = $i;
			$v_pos_entry       = ftell($this->zip_fd);
			$v_extract         = false;
			if ((isset($p_options[ZIP_OPT_BY_NAME])) && ($p_options[ZIP_OPT_BY_NAME] != 0)) {
				for ($j = 0; ($j < sizeof($p_options[ZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {
					if (substr($p_options[ZIP_OPT_BY_NAME][$j], -1) == "/") {
						if ((strlen($v_header['stored_filename']) > strlen($p_options[ZIP_OPT_BY_NAME][$j])) && (substr($v_header['stored_filename'], 0, strlen($p_options[ZIP_OPT_BY_NAME][$j])) == $p_options[ZIP_OPT_BY_NAME][$j])) {
							$v_extract = true;
						}
					} elseif ($v_header['stored_filename'] == $p_options[ZIP_OPT_BY_NAME][$j]) {
						$v_extract = true;
					}
				}
			} else if ((isset($p_options[ZIP_OPT_BY_EREG])) && ($p_options[ZIP_OPT_BY_EREG] != "")) {
				if (ereg($p_options[ZIP_OPT_BY_EREG], $v_header['stored_filename'])) {
					$v_extract = true;
				}
			} else if ((isset($p_options[ZIP_OPT_BY_PREG])) && ($p_options[ZIP_OPT_BY_PREG] != "")) {
				if (preg_match($p_options[ZIP_OPT_BY_PREG], $v_header['stored_filename'])) {
					$v_extract = true;
				}
			} else if ((isset($p_options[ZIP_OPT_BY_INDEX])) && ($p_options[ZIP_OPT_BY_INDEX] != 0)) {
				for ($j = $j_start; ($j < sizeof($p_options[ZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {
					if (($i >= $p_options[ZIP_OPT_BY_INDEX][$j]['start']) && ($i <= $p_options[ZIP_OPT_BY_INDEX][$j]['end'])) {
						$v_extract = true;
					}
					if ($i >= $p_options[ZIP_OPT_BY_INDEX][$j]['end']) {
						$j_start = $j + 1;
					}
					if ($p_options[ZIP_OPT_BY_INDEX][$j]['start'] > $i) {
						break;
					}
				}
			} else {
				$v_extract = true;
			}
			if (($v_extract) && (($v_header['compression'] != 8) && ($v_header['compression'] != 0))) {
				$v_header['status'] = 'unsupported_compression';
				if ((isset($p_options[ZIP_OPT_STOP_ON_ERROR])) && ($p_options[ZIP_OPT_STOP_ON_ERROR] === true)) {
					$this->privSwapBackMagicQuotes();
					$this->privErrorLog(ZIP_ERR_UNSUPPORTED_COMPRESSION, "Filename '" . $v_header['stored_filename'] . "' is " . "compressed by an unsupported compression " . "method (" . $v_header['compression'] . ") ");
					return $this->errorCode();
				}
			}
			if (($v_extract) && (($v_header['flag'] & 1) == 1)) {
				$v_header['status'] = 'unsupported_encryption';
				if ((isset($p_options[ZIP_OPT_STOP_ON_ERROR])) && ($p_options[ZIP_OPT_STOP_ON_ERROR] === true)) {
					$this->privSwapBackMagicQuotes();
					$this->privErrorLog(ZIP_ERR_UNSUPPORTED_ENCRYPTION, "Unsupported encryption for " . " filename '" . $v_header['stored_filename'] . "'");
					return $this->errorCode();
				}
			}
			if (($v_extract) && ($v_header['status'] != 'ok')) {
				$v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++]);
				if ($v_result != 1) {
					$this->privCloseFd();
					$this->privSwapBackMagicQuotes();
					return $v_result;
				}
				$v_extract = false;
			}
			if ($v_extract) {
				@rewind($this->zip_fd);
				if (@fseek($this->zip_fd, $v_header['offset'])) {
					$this->privCloseFd();
					$this->privSwapBackMagicQuotes();
					$this->privErrorLog(ZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');
					return $this->errorCode();
				}
				if ($p_options[ZIP_OPT_EXTRACT_AS_STRING]) {
					$v_result1 = $this->privExtractFileAsString($v_header, $v_string);
					if ($v_result1 < 1) {
						$this->privCloseFd();
						$this->privSwapBackMagicQuotes();
						return $v_result1;
					}
					if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1) {
						$this->privCloseFd();
						$this->privSwapBackMagicQuotes();
						return $v_result;
					}
					$p_file_list[$v_nb_extracted]['content'] = $v_string;
					$v_nb_extracted++;
					if ($v_result1 == 2) {
						break;
					}
				} elseif ((isset($p_options[ZIP_OPT_EXTRACT_IN_OUTPUT])) && ($p_options[ZIP_OPT_EXTRACT_IN_OUTPUT])) {
					$v_result1 = $this->privExtractFileInOutput($v_header, $p_options);
					if ($v_result1 < 1) {
						$this->privCloseFd();
						$this->privSwapBackMagicQuotes();
						return $v_result1;
					}
					if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {
						$this->privCloseFd();
						$this->privSwapBackMagicQuotes();
						return $v_result;
					}
					if ($v_result1 == 2) {
						break;
					}
				} else {
					$v_result1 = $this->privExtractFile($v_header, $p_path, $p_remove_path, $p_remove_all_path, $p_options);
					if ($v_result1 < 1) {
						$this->privCloseFd();
						$this->privSwapBackMagicQuotes();
						return $v_result1;
					}
					if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {
						$this->privCloseFd();
						$this->privSwapBackMagicQuotes();
						return $v_result;
					}
					if ($v_result1 == 2) {
						break;
					}
				}
			}
		}
		$this->privCloseFd();
		$this->privSwapBackMagicQuotes();
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)
	{
		$v_result = 1;
		if (($v_result = $this->privReadFileHeader($v_header)) != 1) {
			return $v_result;
		}
		if ($p_remove_all_path == true) {
			if (($p_entry['external'] & 0x00000010) == 0x00000010) {
				$p_entry['status'] = "filtered";
				return $v_result;
			}
			$p_entry['filename'] = basename($p_entry['filename']);
		} else if ($p_remove_path != "") {
			if ($this->PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2) {
				$p_entry['status'] = "filtered";
				return $v_result;
			}
			$p_remove_path_size = strlen($p_remove_path);
			if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path) {
				$p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);
			}
		}
		if ($p_path != '') {
			$p_entry['filename'] = $p_path . "/" . $p_entry['filename'];
		}
		if (isset($p_options[ZIP_OPT_EXTRACT_DIR_RESTRICTION])) {
			$v_inclusion = $this->PclZipUtilPathInclusion($p_options[ZIP_OPT_EXTRACT_DIR_RESTRICTION], $p_entry['filename']);
			if ($v_inclusion == 0) {
				$this->privErrorLog(ZIP_ERR_DIRECTORY_RESTRICTION, "Filename '" . $p_entry['filename'] . "' is " . "outside ZIP_OPT_EXTRACT_DIR_RESTRICTION");
				return $this->errorCode();
			}
		}
		if (isset($p_options[ZIP_CB_PRE_EXTRACT])) {
			$v_local_header = array();
			$this->privConvertHeader2FileInfo($p_entry, $v_local_header);
			eval('$v_result = ' . $p_options[ZIP_CB_PRE_EXTRACT] . '(ZIP_CB_PRE_EXTRACT, $v_local_header);');
			if ($v_result == 0) {
				$p_entry['status'] = "skipped";
				$v_result          = 1;
			}
			if ($v_result == 2) {
				$p_entry['status'] = "aborted";
				$v_result          = ZIP_ERR_USER_ABORTED;
			}
			$p_entry['filename'] = $v_local_header['filename'];
		}
		if ($p_entry['status'] == 'ok') {
			if (file_exists($p_entry['filename'])) {
				if (is_dir($p_entry['filename'])) {
					$p_entry['status'] = "already_a_directory";
					if ((isset($p_options[ZIP_OPT_STOP_ON_ERROR])) && ($p_options[ZIP_OPT_STOP_ON_ERROR] === true)) {
						$this->privErrorLog(ZIP_ERR_ALREADY_A_DIRECTORY, "Filename '" . $p_entry['filename'] . "' is " . "already used by an existing directory");
						return $this->errorCode();
					}
				} else if (!is_writeable($p_entry['filename'])) {
					$p_entry['status'] = "write_protected";
					if ((isset($p_options[ZIP_OPT_STOP_ON_ERROR])) && ($p_options[ZIP_OPT_STOP_ON_ERROR] === true)) {
						$this->privErrorLog(ZIP_ERR_WRITE_OPEN_FAIL, "Filename '" . $p_entry['filename'] . "' exists " . "and is write protected");
						return $this->errorCode();
					}
				} else if (filemtime($p_entry['filename']) > $p_entry['mtime']) {
					if ((isset($p_options[ZIP_OPT_REPLACE_NEWER])) && ($p_options[ZIP_OPT_REPLACE_NEWER] === true)) {
					} else {
						$p_entry['status'] = "newer_exist";
						if ((isset($p_options[ZIP_OPT_STOP_ON_ERROR])) && ($p_options[ZIP_OPT_STOP_ON_ERROR] === true)) {
							$this->privErrorLog(ZIP_ERR_WRITE_OPEN_FAIL, "Newer version of '" . $p_entry['filename'] . "' exists " . "and option ZIP_OPT_REPLACE_NEWER is not selected");
							return $this->errorCode();
						}
					}
				}
			} else {
				if ((($p_entry['external'] & 0x00000010) == 0x00000010) || (substr($p_entry['filename'], -1) == '/'))
					$v_dir_to_check = $p_entry['filename'];
				else if (!strstr($p_entry['filename'], "/"))
					$v_dir_to_check = "";
				else
					$v_dir_to_check = dirname($p_entry['filename']);
				if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external'] & 0x00000010) == 0x00000010))) != 1) {
					$p_entry['status'] = "path_creation_fail";
					$v_result          = 1;
				}
			}
		}
		if ($p_entry['status'] == 'ok') {
			if (!(($p_entry['external'] & 0x00000010) == 0x00000010)) {
				if ($p_entry['compression'] == 0) {
					if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {
						$p_entry['status'] = "write_error";
						return $v_result;
					}
					$v_size = $p_entry['compressed_size'];
					while ($v_size != 0) {
						$v_read_size = ($v_size < ZIP_READ_BLOCK_SIZE ? $v_size : ZIP_READ_BLOCK_SIZE);
						$v_buffer    = @fread($this->zip_fd, $v_read_size);
						@fwrite($v_dest_file, $v_buffer, $v_read_size);
						$v_size -= $v_read_size;
					}
					fclose($v_dest_file);
					touch($p_entry['filename'], $p_entry['mtime']);
				} else {
					if (($p_entry['flag'] & 1) == 1) {
					} else {
						$v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);
					}
					$v_file_content = @gzinflate($v_buffer);
					unset($v_buffer);
					if ($v_file_content === FALSE) {
						$p_entry['status'] = "error";
						return $v_result;
					}
					if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {
						$p_entry['status'] = "write_error";
						return $v_result;
					}
					@fwrite($v_dest_file, $v_file_content, $p_entry['size']);
					unset($v_file_content);
					@fclose($v_dest_file);
					@touch($p_entry['filename'], $p_entry['mtime']);
				}
				if (isset($p_options[ZIP_OPT_SET_CHMOD])) {
					@chmod($p_entry['filename'], $p_options[ZIP_OPT_SET_CHMOD]);
				}
			}
		}
		if ($p_entry['status'] == "aborted") {
			$p_entry['status'] = "skipped";
		} elseif (isset($p_options[ZIP_CB_POST_EXTRACT])) {
			$v_local_header = array();
			$this->privConvertHeader2FileInfo($p_entry, $v_local_header);
			eval('$v_result = ' . $p_options[ZIP_CB_POST_EXTRACT] . '(ZIP_CB_POST_EXTRACT, $v_local_header);');
			if ($v_result == 2) {
				$v_result = ZIP_ERR_USER_ABORTED;
			}
		}
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privReadFileHeader(&$p_header)
	{
		$v_result      = 1;
		$v_binary_data = @fread($this->zip_fd, 4);
		$v_data        = unpack('Vid', $v_binary_data);
		if ($v_data['id'] != 0x04034b50) {
			$this->privErrorLog(ZIP_ERR_BAD_FORMAT, 'Invalid archive structure');
			return $this->errorCode();
		}
		$v_binary_data = fread($this->zip_fd, 26);
		if (strlen($v_binary_data) != 26) {
			$p_header['filename'] = "";
			$p_header['status']   = "invalid_header";
			$this->privErrorLog(ZIP_ERR_BAD_FORMAT, "Invalid block size : " . strlen($v_binary_data));
			return $this->errorCode();
		}
		$v_data               = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);
		$p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);
		if ($v_data['extra_len'] != 0) {
			$p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);
		} else {
			$p_header['extra'] = '';
		}
		$p_header['version_extracted'] = $v_data['version'];
		$p_header['compression']       = $v_data['compression'];
		$p_header['size']              = $v_data['size'];
		$p_header['compressed_size']   = $v_data['compressed_size'];
		$p_header['crc']               = $v_data['crc'];
		$p_header['flag']              = $v_data['flag'];
		$p_header['filename_len']      = $v_data['filename_len'];
		$p_header['mdate']             = $v_data['mdate'];
		$p_header['mtime']             = $v_data['mtime'];
		if ($p_header['mdate'] && $p_header['mtime']) {
			$v_hour            = ($p_header['mtime'] & 0xF800) >> 11;
			$v_minute          = ($p_header['mtime'] & 0x07E0) >> 5;
			$v_seconde         = ($p_header['mtime'] & 0x001F) * 2;
			$v_year            = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;
			$v_month           = ($p_header['mdate'] & 0x01E0) >> 5;
			$v_day             = $p_header['mdate'] & 0x001F;
			$p_header['mtime'] = mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);
		} else {
			$p_header['mtime'] = time();
		}
		$p_header['stored_filename'] = $p_header['filename'];
		$p_header['status']          = "ok";
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privReadCentralFileHeader(&$p_header)
	{
		$v_result      = 1;
		$v_binary_data = @fread($this->zip_fd, 4);
		$v_data        = unpack('Vid', $v_binary_data);
		if ($v_data['id'] != 0x02014b50) {
			$this->privErrorLog(ZIP_ERR_BAD_FORMAT, 'Invalid archive structure');
			return $this->errorCode();
		}
		$v_binary_data = fread($this->zip_fd, 42);
		if (strlen($v_binary_data) != 42) {
			$p_header['filename'] = "";
			$p_header['status']   = "invalid_header";
			$this->privErrorLog(ZIP_ERR_BAD_FORMAT, "Invalid block size : " . strlen($v_binary_data));
			return $this->errorCode();
		}
		$p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);
		if ($p_header['filename_len'] != 0)
			$p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);
		else
			$p_header['filename'] = '';
		if ($p_header['extra_len'] != 0)
			$p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);
		else
			$p_header['extra'] = '';
		if ($p_header['comment_len'] != 0)
			$p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);
		else
			$p_header['comment'] = '';
		if (1) {
			$v_hour            = ($p_header['mtime'] & 0xF800) >> 11;
			$v_minute          = ($p_header['mtime'] & 0x07E0) >> 5;
			$v_seconde         = ($p_header['mtime'] & 0x001F) * 2;
			$v_year            = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;
			$v_month           = ($p_header['mdate'] & 0x01E0) >> 5;
			$v_day             = $p_header['mdate'] & 0x001F;
			$p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);
		} else {
			$p_header['mtime'] = time();
		}
		$p_header['stored_filename'] = $p_header['filename'];
		$p_header['status']          = 'ok';
		if (substr($p_header['filename'], -1) == '/') {
			$p_header['external'] = 0x00000010;
		}
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privReadEndCentralDir(&$p_central_dir)
	{
		$v_result = 1;
		$v_size   = filesize($this->zipname);
		@fseek($this->zip_fd, $v_size);
		if (@ftell($this->zip_fd) != $v_size) {
			$this->privErrorLog(ZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \'' . $this->zipname . '\'');
			return $this->errorCode();
		}
		$v_found = 0;
		if ($v_size > 26) {
			@fseek($this->zip_fd, $v_size - 22);
			if (($v_pos = @ftell($this->zip_fd)) != ($v_size - 22)) {
				$this->privErrorLog(ZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \'' . $this->zipname . '\'');
				return $this->errorCode();
			}
			$v_binary_data = @fread($this->zip_fd, 4);
			$v_data        = @unpack('Vid', $v_binary_data);
			if ($v_data['id'] == 0x06054b50) {
				$v_found = 1;
			}
			$v_pos = ftell($this->zip_fd);
		}
		if (!$v_found) {
			$v_maximum_size = 65557;
			if ($v_maximum_size > $v_size)
				$v_maximum_size = $v_size;
			@fseek($this->zip_fd, $v_size - $v_maximum_size);
			if (@ftell($this->zip_fd) != ($v_size - $v_maximum_size)) {
				$this->privErrorLog(ZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \'' . $this->zipname . '\'');
				return $this->errorCode();
			}
			$v_pos   = ftell($this->zip_fd);
			$v_bytes = 0x00000000;
			while ($v_pos < $v_size) {
				$v_byte  = @fread($this->zip_fd, 1);
				$v_bytes = ($v_bytes << 8) | Ord($v_byte);
				if ($v_bytes == 0x504b0506) {
					$v_pos++;
					break;
				}
				$v_pos++;
			}
			if ($v_pos == $v_size) {
				$this->privErrorLog(ZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature");
				return $this->errorCode();
			}
		}
		$v_binary_data = fread($this->zip_fd, 18);
		if (strlen($v_binary_data) != 18) {
			$this->privErrorLog(ZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : " . strlen($v_binary_data));
			return $this->errorCode();
		}
		$v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);
		if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {
			if (0) {
				$this->privErrorLog(ZIP_ERR_BAD_FORMAT, 'The central dir is not at the end of the archive.' . ' Some trailing bytes exists after the archive.');
				return $this->errorCode();
			}
		}
		if ($v_data['comment_size'] != 0) {
			$p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);
		} else
			$p_central_dir['comment'] = '';
		$p_central_dir['entries']      = $v_data['entries'];
		$p_central_dir['disk_entries'] = $v_data['disk_entries'];
		$p_central_dir['offset']       = $v_data['offset'];
		$p_central_dir['size']         = $v_data['size'];
		$p_central_dir['disk']         = $v_data['disk'];
		$p_central_dir['disk_start']   = $v_data['disk_start'];
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privDirCheck($p_dir, $p_is_dir = false)
	{
		$v_result = 1;
		if (($p_is_dir) && (substr($p_dir, -1) == '/')) {
			$p_dir = substr($p_dir, 0, strlen($p_dir) - 1);
		}
		if ((is_dir($p_dir)) || ($p_dir == "")) {
			return 1;
		}
		$p_parent_dir = dirname($p_dir);
		if ($p_parent_dir != $p_dir) {
			if ($p_parent_dir != "") {
				if (($v_result = $this->privDirCheck($p_parent_dir)) != 1) {
					return $v_result;
				}
			}
		}
		if (!@mkdir($p_dir, 0777)) {
			$this->privErrorLog(ZIP_ERR_DIR_CREATE_FAIL, "Unable to create directory '$p_dir'");
			return $this->errorCode();
		}
		return $v_result;
	}
	
	// ----------------------------------------------------------------------

	public function privErrorLog($p_error_code = 0, $p_error_string = '')
	{
		if (ZIP_ERROR_EXTERNAL == 1) {
			PclError($p_error_code, $p_error_string);
		} else {
			$this->error_code   = $p_error_code;
			$this->error_string = $p_error_string;
		}
	}
	
	// ----------------------------------------------------------------------

	public function privErrorReset()
	{
		if (ZIP_ERROR_EXTERNAL == 1) {
			PclErrorReset();
		} else {
			$this->error_code   = 0;
			$this->error_string = '';
		}
	}
	
	// ----------------------------------------------------------------------

	public function privDisableMagicQuotes()
	{
		$v_result = 1;
		if ((!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) {
			return $v_result;
		}
		if ($this->magic_quotes_status != -1) {
			return $v_result;
		}
		$this->magic_quotes_status = @get_magic_quotes_runtime();
		if ($this->magic_quotes_status == 1) {
			@set_magic_quotes_runtime(0);
		}
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function privSwapBackMagicQuotes()
	{
		$v_result = 1;
		if ((!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) {
			return $v_result;
		}
		if ($this->magic_quotes_status != -1) {
			return $v_result;
		}
		if ($this->magic_quotes_status == 1) {
			@set_magic_quotes_runtime($this->magic_quotes_status);
		}
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function PclZipUtilPathReduction($p_dir)
	{
		$v_result = "";
		if ($p_dir != "") {
			$v_list = explode("/", $p_dir);
			$v_skip = 0;
			for ($i = sizeof($v_list) - 1; $i >= 0; $i--) {
				if ($v_list[$i] == ".") {
				} else if ($v_list[$i] == "..") {
					$v_skip++;
				} else if ($v_list[$i] == "") {
					if ($i == 0) {
						$v_result = "/" . $v_result;
						if ($v_skip > 0) {
							$v_result = $p_dir;
							$v_skip   = 0;
						}
					} else if ($i == (sizeof($v_list) - 1)) {
						$v_result = $v_list[$i];
					} else {
					}
				} else {
					if ($v_skip > 0) {
						$v_skip--;
					} else {
						$v_result = $v_list[$i] . ($i != (sizeof($v_list) - 1) ? "/" . $v_result : "");
					}
				}
			}
			if ($v_skip > 0) {
				while ($v_skip > 0) {
					$v_result = '../' . $v_result;
					$v_skip--;
				}
			}
		}
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function PclZipUtilPathInclusion($p_dir, $p_path)
	{
		$v_result = 1;
		if (($p_dir == '.') || ((strlen($p_dir) >= 2) && (substr($p_dir, 0, 2) == './'))) {
			$p_dir = $this->PclZipUtilTranslateWinPath(getcwd(), FALSE) . '/' . substr($p_dir, 1);
		}
		if (($p_path == '.') || ((strlen($p_path) >= 2) && (substr($p_path, 0, 2) == './'))) {
			$p_path = $this->PclZipUtilTranslateWinPath(getcwd(), FALSE) . '/' . substr($p_path, 1);
		}
		$v_list_dir       = explode("/", $p_dir);
		$v_list_dir_size  = sizeof($v_list_dir);
		$v_list_path      = explode("/", $p_path);
		$v_list_path_size = sizeof($v_list_path);
		$i                = 0;
		$j                = 0;
		while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {
			if ($v_list_dir[$i] == '') {
				$i++;
				continue;
			}
			if ($v_list_path[$j] == '') {
				$j++;
				continue;
			}
			if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ($v_list_path[$j] != '')) {
				$v_result = 0;
			}
			$i++;
			$j++;
		}
		if ($v_result) {
			while (($j < $v_list_path_size) && ($v_list_path[$j] == ''))
				$j++;
			while (($i < $v_list_dir_size) && ($v_list_dir[$i] == ''))
				$i++;
			if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {
				$v_result = 2;
			} else if ($i < $v_list_dir_size) {
				$v_result = 0;
			}
		}
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode = 0)
	{
		$v_result = 1;
		if ($p_mode == 0) {
			while ($p_size != 0) {
				$v_read_size = ($p_size < ZIP_READ_BLOCK_SIZE ? $p_size : ZIP_READ_BLOCK_SIZE);
				$v_buffer    = @fread($p_src, $v_read_size);
				@fwrite($p_dest, $v_buffer, $v_read_size);
				$p_size -= $v_read_size;
			}
		} else if ($p_mode == 1) {
			while ($p_size != 0) {
				$v_read_size = ($p_size < ZIP_READ_BLOCK_SIZE ? $p_size : ZIP_READ_BLOCK_SIZE);
				$v_buffer    = @gzread($p_src, $v_read_size);
				@fwrite($p_dest, $v_buffer, $v_read_size);
				$p_size -= $v_read_size;
			}
		} else if ($p_mode == 2) {
			while ($p_size != 0) {
				$v_read_size = ($p_size < ZIP_READ_BLOCK_SIZE ? $p_size : ZIP_READ_BLOCK_SIZE);
				$v_buffer    = @fread($p_src, $v_read_size);
				@gzwrite($p_dest, $v_buffer, $v_read_size);
				$p_size -= $v_read_size;
			}
		} else if ($p_mode == 3) {
			while ($p_size != 0) {
				$v_read_size = ($p_size < ZIP_READ_BLOCK_SIZE ? $p_size : ZIP_READ_BLOCK_SIZE);
				$v_buffer    = @gzread($p_src, $v_read_size);
				@gzwrite($p_dest, $v_buffer, $v_read_size);
				$p_size -= $v_read_size;
			}
		}
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function PclZipUtilRename($p_src, $p_dest)
	{
		$v_result = 1;
		if (!@rename($p_src, $p_dest)) {
			if (!@copy($p_src, $p_dest)) {
				$v_result = 0;
			} else if (!@unlink($p_src)) {
				$v_result = 0;
			}
		}
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function PclZipUtilOptionText($p_option)
	{
		$v_list = get_defined_constants();
		for (reset($v_list); $v_key = key($v_list); next($v_list)) {
			$v_prefix = substr($v_key, 0, 10);
			if ((($v_prefix == 'ZIP_OPT') || ($v_prefix == 'ZIP_CB_') || ($v_prefix == 'ZIP_ATT')) && ($v_list[$v_key] == $p_option)) {
				return $v_key;
			}
		}
		$v_result = 'Unknown';
		return $v_result;
	}

	// ----------------------------------------------------------------------

	public function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter = true)
	{
		if (stristr(php_uname(), 'windows')) {
			if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {
				$p_path = substr($p_path, $v_position + 1);
			}
			if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0, 1) == '\\')) {
				$p_path = strtr($p_path, '\\', '/');
			}
		}
		return $p_path;
	}
} // End Class